"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var glob_1 = require("glob");
var misc_utils_of_mine_generic_1 = require("misc-utils-of-mine-generic");
var path_1 = require("path");
var library_1 = require("../library");
var renderDot_1 = require("../renderDot");
function cliMain(o) {
    return __awaiter(this, void 0, void 0, function () {
        var files, input, error_1;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    preconditions(o);
                    files = glob_1.sync(o.input).filter(fs_1.existsSync);
                    input = files.length ? files.map(function (f) { return ({
                        name: f,
                        content: fs_1.readFileSync(f).toString()
                    }); }) : [{
                            name: 'input.dot',
                            content: o.input
                        }];
                    if (o.output && !fs_1.existsSync(o.output)) {
                        fs_1.mkdirSync(o.output, { recursive: true });
                    }
                    return [4 /*yield*/, misc_utils_of_mine_generic_1.serial(input.map(function (input) { return function () { return __awaiter(_this, void 0, void 0, function () {
                            var result, _a, file, error_2;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _b.trys.push([0, 2, , 3]);
                                        o.debug && console.log('Rendering ' + input.name);
                                        _a = {
                                            name: input.name + ("." + (o.format || 'svg'))
                                        };
                                        return [4 /*yield*/, renderDot_1.renderDot(__assign({}, o, { input: input.content }))];
                                    case 1:
                                        result = (_a.content = _b.sent(),
                                            _a);
                                        // o.debug && console.log('Rendered ' + input.name)
                                        if (o.output) {
                                            file = path_1.join(o.output, path_1.basename(result.name));
                                            // o.debug && console.log('Writing ' + file)
                                            if (!o.format || o.format === 'svg') {
                                                fs_1.writeFileSync(file, result.content);
                                            }
                                            else {
                                                fs_1.writeFileSync(file, result.content, 'binary');
                                            }
                                        }
                                        else {
                                            process.stdout.write(result.content);
                                        }
                                        return [3 /*break*/, 3];
                                    case 2:
                                        error_2 = _b.sent();
                                        console.error('ERROR while rendering file ' + input.name);
                                        console.error(error_2);
                                        return [3 /*break*/, 3];
                                    case 3: return [4 /*yield*/, misc_utils_of_mine_generic_1.sleep(10)];
                                    case 4:
                                        _b.sent();
                                        return [2 /*return*/];
                                }
                            });
                        }); }; }))];
                case 1:
                    _a.sent();
                    o.debug && console.log('Terminating Library');
                    library_1.terminateLibrary();
                    return [3 /*break*/, 3];
                case 2:
                    error_1 = _a.sent();
                    fail(error_1);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.cliMain = cliMain;
function preconditions(options) {
    if (options.help) {
        printHelp();
        library_1.terminateLibrary();
        process.exit(0);
    }
    if (!options.input) {
        fail("--input is mandatory but one was not given. Aborting.");
    }
    if (options.nop) {
        options.nop = parseInt(options.nop + '');
    }
}
function fail(s) {
    console.error(s);
    library_1.terminateLibrary();
    process.exit(1);
}
function printHelp() {
    console.log("\nUsage: \n\nrender-dot --input \"**/*go*/*.dot\" --output ../svgs\nrender-dot --input graph1.dot --format ps > graph1.ps\n\nOptions:\n\n * --input: string;: .dot code to render. For Command line, it can also be path to .dot files or glob pattern to many .dot files, relative to current dir.\n * --width?: number;: Output image width. \n * --height?: number;: Output image height. \n * --format?: 'svg' | 'png' | 'jpeg' | 'gif' | 'json' | 'xdot' | 'plain' | 'ps' | 'eps' | 'ps2' | 'pic' | 'vml' | 'xdot_json' | 'plain_ext' | 'pov': Output format. One of:  'svg' | 'png' | 'jpeg' | 'gif' | 'json' | 'xdot' | 'plain' | 'ps'|   'eps'| 'ps2'| 'pic'| 'vml'| 'xdot_json'| 'plain_ext'| 'pov'. By default: svg.\n * --engine?: Engine;: Graph layout implementation. One of : dot, circo, fdp, neato, asage, twopi, patchwork, sfdp. By default: dot.\n * --quality?: number;: Quality of output image.\n * --scale?: number;: Set input scale to scale. If this value is omitted, 72.0 is used. This number is used to convert the point coordinate units used in the pos attribute into inches, which is what is expected by neato and fdp. Thus, feeding the output of a graph laid out by one program into neato or fdp almost always requires this flag. Ignored if the -n flag is used.\n * --yInvert?: boolean: By default, the coordinate system used in generic output formats, such as attributed dot, extended dot, plain and plain-ext, is the standard cartesian system with the origin in the lower left corner, and with increasing y coordinates as points move from bottom to top. If the -y flag is used, the coordinate system is inverted, so that increasing values of y correspond to movement from top to bottom.\n * --nop?: number;: Sets no-op flag in neato. If set, neato assumes nodes have already been positioned and all nodes have a pos attribute giving the positions. It then performs an optional adjustment to remove node-node overlap, depending on the value of the overlap attribute, computes the edge layouts, depending on the value of the splines attribute, and emits the graph in the appropriate format. If num is supplied, the following actions occur: \n   - num = 1 : Equivalent to -n.\n   - num > 1: Use node positions as specified, with no adjustment to remove node-node overlaps, and use any edge layouts already specified by the pos attribute. neato computes an edge layout for any edge that does not have a pos attribute. As usual, edge layout is guided by the splines attribute.\n * --output?: string: Folder for output files. If it doesn't exists it will be created. If none, output will be written to stdout.\n * --help?: boolean: Print usage information, then exit.\n * --debug?: boolean: Prints debug messages.\n\n");
}
//# sourceMappingURL=cli.js.map